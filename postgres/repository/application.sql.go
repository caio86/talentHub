// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: application.sql

package repository

import (
	"context"
	"time"
)

const countApplications = `-- name: CountApplications :one
SELECT count(*) FROM applications
`

func (q *Queries) CountApplications(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countApplications)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getApplicationById = `-- name: GetApplicationById :one
SELECT id, candidate_id, vacancy_id, application_date, score, status_id FROM applications
WHERE id = $1
`

func (q *Queries) GetApplicationById(ctx context.Context, id int32) (Application, error) {
	row := q.db.QueryRow(ctx, getApplicationById, id)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.CandidateID,
		&i.VacancyID,
		&i.ApplicationDate,
		&i.Score,
		&i.StatusID,
	)
	return i, err
}

const getApplicationStatusById = `-- name: GetApplicationStatusById :one
SELECT id, status FROM application_status
WHERE id = $1
`

func (q *Queries) GetApplicationStatusById(ctx context.Context, id int32) (ApplicationStatus, error) {
	row := q.db.QueryRow(ctx, getApplicationStatusById, id)
	var i ApplicationStatus
	err := row.Scan(&i.ID, &i.Status)
	return i, err
}

const getApplicationStatusByName = `-- name: GetApplicationStatusByName :one

SELECT id, status FROM application_status
WHERE status = $1
`

// application status
func (q *Queries) GetApplicationStatusByName(ctx context.Context, status string) (ApplicationStatus, error) {
	row := q.db.QueryRow(ctx, getApplicationStatusByName, status)
	var i ApplicationStatus
	err := row.Scan(&i.ID, &i.Status)
	return i, err
}

const getFullApplicationById = `-- name: GetFullApplicationById :one
SELECT a.id, a.candidate_id, a.vacancy_id, a.application_date, a.score, a.status_id, s.status as status FROM applications a
LEFT JOIN application_status s ON a.status_id = s.id
WHERE a.id = $1
`

type GetFullApplicationByIdRow struct {
	ID              int32     `json:"id"`
	CandidateID     int32     `json:"candidate_id"`
	VacancyID       int32     `json:"vacancy_id"`
	ApplicationDate time.Time `json:"application_date"`
	Score           int32     `json:"score"`
	StatusID        *int32    `json:"status_id"`
	Status          *string   `json:"status"`
}

func (q *Queries) GetFullApplicationById(ctx context.Context, id int32) (GetFullApplicationByIdRow, error) {
	row := q.db.QueryRow(ctx, getFullApplicationById, id)
	var i GetFullApplicationByIdRow
	err := row.Scan(
		&i.ID,
		&i.CandidateID,
		&i.VacancyID,
		&i.ApplicationDate,
		&i.Score,
		&i.StatusID,
		&i.Status,
	)
	return i, err
}

const listAllApplications = `-- name: ListAllApplications :many
SELECT id, candidate_id, vacancy_id, application_date, score, status_id FROM applications
`

func (q *Queries) ListAllApplications(ctx context.Context) ([]Application, error) {
	rows, err := q.db.Query(ctx, listAllApplications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.CandidateID,
			&i.VacancyID,
			&i.ApplicationDate,
			&i.Score,
			&i.StatusID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllFullApplications = `-- name: ListAllFullApplications :many
SELECT a.id, a.candidate_id, a.vacancy_id, a.application_date, a.score, a.status_id, s.status as status FROM applications a
LEFT JOIN application_status s ON a.status_id = s.id
`

type ListAllFullApplicationsRow struct {
	ID              int32     `json:"id"`
	CandidateID     int32     `json:"candidate_id"`
	VacancyID       int32     `json:"vacancy_id"`
	ApplicationDate time.Time `json:"application_date"`
	Score           int32     `json:"score"`
	StatusID        *int32    `json:"status_id"`
	Status          *string   `json:"status"`
}

func (q *Queries) ListAllFullApplications(ctx context.Context) ([]ListAllFullApplicationsRow, error) {
	rows, err := q.db.Query(ctx, listAllFullApplications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllFullApplicationsRow
	for rows.Next() {
		var i ListAllFullApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.CandidateID,
			&i.VacancyID,
			&i.ApplicationDate,
			&i.Score,
			&i.StatusID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicationStatuses = `-- name: ListApplicationStatuses :many
SELECT id, status FROM application_status
`

func (q *Queries) ListApplicationStatuses(ctx context.Context) ([]ApplicationStatus, error) {
	rows, err := q.db.Query(ctx, listApplicationStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationStatus
	for rows.Next() {
		var i ApplicationStatus
		if err := rows.Scan(&i.ID, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplications = `-- name: ListApplications :many
SELECT id, candidate_id, vacancy_id, application_date, score, status_id FROM applications
LIMIT $1 OFFSET $2
`

type ListApplicationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListApplications(ctx context.Context, arg ListApplicationsParams) ([]Application, error) {
	rows, err := q.db.Query(ctx, listApplications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.CandidateID,
			&i.VacancyID,
			&i.ApplicationDate,
			&i.Score,
			&i.StatusID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFullApplications = `-- name: ListFullApplications :many
SELECT a.id, a.candidate_id, a.vacancy_id, a.application_date, a.score, a.status_id, s.status as status FROM applications a
LEFT JOIN application_status s ON a.status_id = s.id
LIMIT $1 OFFSET $2
`

type ListFullApplicationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListFullApplicationsRow struct {
	ID              int32     `json:"id"`
	CandidateID     int32     `json:"candidate_id"`
	VacancyID       int32     `json:"vacancy_id"`
	ApplicationDate time.Time `json:"application_date"`
	Score           int32     `json:"score"`
	StatusID        *int32    `json:"status_id"`
	Status          *string   `json:"status"`
}

func (q *Queries) ListFullApplications(ctx context.Context, arg ListFullApplicationsParams) ([]ListFullApplicationsRow, error) {
	rows, err := q.db.Query(ctx, listFullApplications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFullApplicationsRow
	for rows.Next() {
		var i ListFullApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.CandidateID,
			&i.VacancyID,
			&i.ApplicationDate,
			&i.Score,
			&i.StatusID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerApplication = `-- name: RegisterApplication :one
INSERT INTO applications (
  candidate_id, vacancy_id, status_id
) VALUES (
  $1, $2, $3
) RETURNING id, candidate_id, vacancy_id, application_date, score, status_id
`

type RegisterApplicationParams struct {
	CandidateID int32  `json:"candidate_id"`
	VacancyID   int32  `json:"vacancy_id"`
	StatusID    *int32 `json:"status_id"`
}

func (q *Queries) RegisterApplication(ctx context.Context, arg RegisterApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, registerApplication, arg.CandidateID, arg.VacancyID, arg.StatusID)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.CandidateID,
		&i.VacancyID,
		&i.ApplicationDate,
		&i.Score,
		&i.StatusID,
	)
	return i, err
}

const searchApplicationsByCandidateId = `-- name: SearchApplicationsByCandidateId :many
SELECT a.id, a.candidate_id, a.vacancy_id, a.application_date, a.score, a.status_id FROM applications a
JOIN candidates c ON a.candidate_id = c.id
WHERE c.id = $1
`

func (q *Queries) SearchApplicationsByCandidateId(ctx context.Context, id int32) ([]Application, error) {
	rows, err := q.db.Query(ctx, searchApplicationsByCandidateId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.CandidateID,
			&i.VacancyID,
			&i.ApplicationDate,
			&i.Score,
			&i.StatusID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchApplicationsByVacancyId = `-- name: SearchApplicationsByVacancyId :many
SELECT a.id, a.candidate_id, a.vacancy_id, a.application_date, a.score, a.status_id FROM applications a
JOIN vacancies v ON a.vacancy_id = v.id
WHERE v.id = $1
`

func (q *Queries) SearchApplicationsByVacancyId(ctx context.Context, id int32) ([]Application, error) {
	rows, err := q.db.Query(ctx, searchApplicationsByVacancyId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.CandidateID,
			&i.VacancyID,
			&i.ApplicationDate,
			&i.Score,
			&i.StatusID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unregisterApplication = `-- name: UnregisterApplication :exec
DELETE FROM applications
  WHERE id = $1
`

func (q *Queries) UnregisterApplication(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, unregisterApplication, id)
	return err
}

const updateApplication = `-- name: UpdateApplication :one
UPDATE applications
  SET
    score = $2,
    status_id = $3
  WHERE id = $1
  RETURNING id, candidate_id, vacancy_id, application_date, score, status_id
`

type UpdateApplicationParams struct {
	ID       int32  `json:"id"`
	Score    int32  `json:"score"`
	StatusID *int32 `json:"status_id"`
}

func (q *Queries) UpdateApplication(ctx context.Context, arg UpdateApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, updateApplication, arg.ID, arg.Score, arg.StatusID)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.CandidateID,
		&i.VacancyID,
		&i.ApplicationDate,
		&i.Score,
		&i.StatusID,
	)
	return i, err
}
