// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: vacancies.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addRequirement = `-- name: AddRequirement :one

INSERT INTO requirements (name)
  VALUES ($1)
  ON CONFLICT DO NOTHING
RETURNING id, name
`

// Requirements
func (q *Queries) AddRequirement(ctx context.Context, name string) (Requirement, error) {
	row := q.db.QueryRow(ctx, addRequirement, name)
	var i Requirement
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const addVacancyRequirement = `-- name: AddVacancyRequirement :exec
INSERT INTO vacancy_requirements (vacancy_id, requirement_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
RETURNING vacancy_id, requirement_id
`

type AddVacancyRequirementParams struct {
	VacancyID     int32 `json:"vacancy_id"`
	RequirementID int32 `json:"requirement_id"`
}

func (q *Queries) AddVacancyRequirement(ctx context.Context, arg AddVacancyRequirementParams) error {
	_, err := q.db.Exec(ctx, addVacancyRequirement, arg.VacancyID, arg.RequirementID)
	return err
}

const countVacancies = `-- name: CountVacancies :one
SELECT count(*) FROM vacancies
`

func (q *Queries) CountVacancies(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countVacancies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVacancy = `-- name: CreateVacancy :one
INSERT INTO vacancies (
  title, description, is_active, area_id, type_id, location, posted_date
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
) RETURNING id, title, description, is_active, area_id, type_id, location, posted_date
`

type CreateVacancyParams struct {
	Title       string      `json:"title"`
	Description *string     `json:"description"`
	IsActive    bool        `json:"is_active"`
	AreaID      *int32      `json:"area_id"`
	TypeID      *int32      `json:"type_id"`
	Location    *string     `json:"location"`
	PostedDate  pgtype.Date `json:"posted_date"`
}

func (q *Queries) CreateVacancy(ctx context.Context, arg CreateVacancyParams) (Vacancy, error) {
	row := q.db.QueryRow(ctx, createVacancy,
		arg.Title,
		arg.Description,
		arg.IsActive,
		arg.AreaID,
		arg.TypeID,
		arg.Location,
		arg.PostedDate,
	)
	var i Vacancy
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.AreaID,
		&i.TypeID,
		&i.Location,
		&i.PostedDate,
	)
	return i, err
}

const deleteVacancy = `-- name: DeleteVacancy :exec
DELETE FROM vacancies
WHERE id = $1
`

func (q *Queries) DeleteVacancy(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteVacancy, id)
	return err
}

const getAreaByID = `-- name: GetAreaByID :one
SELECT id, name FROM employment_areas
WHERE id = $1
`

// Area
func (q *Queries) GetAreaByID(ctx context.Context, id int32) (EmploymentArea, error) {
	row := q.db.QueryRow(ctx, getAreaByID, id)
	var i EmploymentArea
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getAreaByName = `-- name: GetAreaByName :one
SELECT id, name FROM employment_areas
WHERE name = $1
`

func (q *Queries) GetAreaByName(ctx context.Context, name string) (EmploymentArea, error) {
	row := q.db.QueryRow(ctx, getAreaByName, name)
	var i EmploymentArea
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getFullVacancyByID = `-- name: GetFullVacancyByID :one
SELECT v.id, v.title, v.description, v.is_active, v.area_id, v.type_id, v.location, v.posted_date, ea.name as area, et.name as type from vacancies v
LEFT JOIN employment_areas ea ON v.area_id = ea.id
LEFT JOIN employment_types et ON v.type_id = et.id
WHERE v.id = $1
`

type GetFullVacancyByIDRow struct {
	ID          int32       `json:"id"`
	Title       string      `json:"title"`
	Description *string     `json:"description"`
	IsActive    bool        `json:"is_active"`
	AreaID      *int32      `json:"area_id"`
	TypeID      *int32      `json:"type_id"`
	Location    *string     `json:"location"`
	PostedDate  pgtype.Date `json:"posted_date"`
	Area        *string     `json:"area"`
	Type        *string     `json:"type"`
}

func (q *Queries) GetFullVacancyByID(ctx context.Context, id int32) (GetFullVacancyByIDRow, error) {
	row := q.db.QueryRow(ctx, getFullVacancyByID, id)
	var i GetFullVacancyByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.AreaID,
		&i.TypeID,
		&i.Location,
		&i.PostedDate,
		&i.Area,
		&i.Type,
	)
	return i, err
}

const getRequirementByName = `-- name: GetRequirementByName :one
SELECT id, name FROM requirements
WHERE name = $1
`

func (q *Queries) GetRequirementByName(ctx context.Context, name string) (Requirement, error) {
	row := q.db.QueryRow(ctx, getRequirementByName, name)
	var i Requirement
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getRequirementsByVacancyID = `-- name: GetRequirementsByVacancyID :many
SELECT name FROM requirements r
JOIN vacancy_requirements vr ON r.id = vr.requirement_id
JOIN vacancies v ON v.id = vr.vacancy_id
WHERE v.id = $1
`

func (q *Queries) GetRequirementsByVacancyID(ctx context.Context, id int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getRequirementsByVacancyID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypeByID = `-- name: GetTypeByID :one
SELECT id, name FROM employment_types
WHERE id = $1
`

// Type
func (q *Queries) GetTypeByID(ctx context.Context, id int32) (EmploymentType, error) {
	row := q.db.QueryRow(ctx, getTypeByID, id)
	var i EmploymentType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getTypeByName = `-- name: GetTypeByName :one
SELECT id, name FROM employment_types
WHERE name = $1
`

func (q *Queries) GetTypeByName(ctx context.Context, name string) (EmploymentType, error) {
	row := q.db.QueryRow(ctx, getTypeByName, name)
	var i EmploymentType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getVacancyByID = `-- name: GetVacancyByID :one
SELECT id, title, description, is_active, area_id, type_id, location, posted_date FROM vacancies
WHERE id = $1
`

func (q *Queries) GetVacancyByID(ctx context.Context, id int32) (Vacancy, error) {
	row := q.db.QueryRow(ctx, getVacancyByID, id)
	var i Vacancy
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.AreaID,
		&i.TypeID,
		&i.Location,
		&i.PostedDate,
	)
	return i, err
}

const listAllVacancies = `-- name: ListAllVacancies :many
SELECT v.id, v.title, v.description, v.is_active, v.area_id, v.type_id, v.location, v.posted_date, ea.name as area, et.name as type from vacancies v
LEFT JOIN employment_areas ea ON v.area_id = ea.id
LEFT JOIN employment_types et ON v.type_id = et.id
ORDER BY title
`

type ListAllVacanciesRow struct {
	ID          int32       `json:"id"`
	Title       string      `json:"title"`
	Description *string     `json:"description"`
	IsActive    bool        `json:"is_active"`
	AreaID      *int32      `json:"area_id"`
	TypeID      *int32      `json:"type_id"`
	Location    *string     `json:"location"`
	PostedDate  pgtype.Date `json:"posted_date"`
	Area        *string     `json:"area"`
	Type        *string     `json:"type"`
}

func (q *Queries) ListAllVacancies(ctx context.Context) ([]ListAllVacanciesRow, error) {
	rows, err := q.db.Query(ctx, listAllVacancies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllVacanciesRow
	for rows.Next() {
		var i ListAllVacanciesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.AreaID,
			&i.TypeID,
			&i.Location,
			&i.PostedDate,
			&i.Area,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVacancies = `-- name: ListVacancies :many
SELECT v.id, v.title, v.description, v.is_active, v.area_id, v.type_id, v.location, v.posted_date, ea.name as area, et.name as type from vacancies v
LEFT JOIN employment_areas ea ON v.area_id = ea.id
LEFT JOIN employment_types et ON v.type_id = et.id
ORDER BY title
LIMIT $1 OFFSET $2
`

type ListVacanciesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListVacanciesRow struct {
	ID          int32       `json:"id"`
	Title       string      `json:"title"`
	Description *string     `json:"description"`
	IsActive    bool        `json:"is_active"`
	AreaID      *int32      `json:"area_id"`
	TypeID      *int32      `json:"type_id"`
	Location    *string     `json:"location"`
	PostedDate  pgtype.Date `json:"posted_date"`
	Area        *string     `json:"area"`
	Type        *string     `json:"type"`
}

func (q *Queries) ListVacancies(ctx context.Context, arg ListVacanciesParams) ([]ListVacanciesRow, error) {
	rows, err := q.db.Query(ctx, listVacancies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVacanciesRow
	for rows.Next() {
		var i ListVacanciesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.IsActive,
			&i.AreaID,
			&i.TypeID,
			&i.Location,
			&i.PostedDate,
			&i.Area,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeVacancyRequirement = `-- name: RemoveVacancyRequirement :exec
DELETE FROM vacancy_requirements
WHERE vacancy_id = $1 AND requirement_id = $2
`

type RemoveVacancyRequirementParams struct {
	VacancyID     int32 `json:"vacancy_id"`
	RequirementID int32 `json:"requirement_id"`
}

func (q *Queries) RemoveVacancyRequirement(ctx context.Context, arg RemoveVacancyRequirementParams) error {
	_, err := q.db.Exec(ctx, removeVacancyRequirement, arg.VacancyID, arg.RequirementID)
	return err
}

const updateVacancy = `-- name: UpdateVacancy :one
UPDATE vacancies
SET
  title = $2,
  description = $3,
  location = $4,
  area_id = $5,
  type_id = $6
WHERE id = $1
RETURNING id, title, description, is_active, area_id, type_id, location, posted_date
`

type UpdateVacancyParams struct {
	ID          int32   `json:"id"`
	Title       string  `json:"title"`
	Description *string `json:"description"`
	Location    *string `json:"location"`
	AreaID      *int32  `json:"area_id"`
	TypeID      *int32  `json:"type_id"`
}

func (q *Queries) UpdateVacancy(ctx context.Context, arg UpdateVacancyParams) (Vacancy, error) {
	row := q.db.QueryRow(ctx, updateVacancy,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Location,
		arg.AreaID,
		arg.TypeID,
	)
	var i Vacancy
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.IsActive,
		&i.AreaID,
		&i.TypeID,
		&i.Location,
		&i.PostedDate,
	)
	return i, err
}
